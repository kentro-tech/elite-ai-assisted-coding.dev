---
title: "Automated Context Personalization with Spec Story"
author: "Isaac Flath"
date: "7/25/2025"
format:
  html:
    number-sections: true
    toc: true
    theme: cosmo
    highlight-style: tango
    code-fold: true
    self-contained: true
open-graph:
  title: "Automated Context Personalization with Spec Story"
  description: "A proposal for mining conversation history to automatically update and personalize AI context."
twitter-card:
  title: "Automated Context Personalization with Spec Story"
  description: "A proposal for mining conversation history to automatically update and personalize AI context."
  card-style: summary_large_image
---

This presentation outlines a partnership opportunity with Spec Story to solve one of the biggest challenges in AI-assisted development: context personalization. We propose a system to automatically mine developer-AI conversations to create and maintain personalized context, ensuring the AI's assistance is always aligned with a project's evolving needs and a developer's unique tastes.

## 1. The Problem: The Manual Context Treadmill

Keeping an AI assistant useful requires feeding it the right context. Why bother?

-   **Better AI assistance**: Context is the foundation of relevant, high-quality AI responses.
-   **Overcoming Knowledge Cutoffs**: Models have outdated information; context provides the latest updates.
-   **Enforcing Standards**: Context helps the AI match your project's specific tastes, abstractions, and framework usage.

However, the current approach to managing this context is manual, brittle, and time-consuming.

### The Three Layers of Context

We can think of context in three layers, each requiring progressively more effort to maintain.

1.  **General Context**: Generic, tool-provided context (e.g., Repomix, GitMCP). It's a good starting point but lacks specificity.
2.  **Curated Context**: Expert-curated context, often from a library author (e.g., `llms.txt`, official MCP servers). Better, but not tailored to your project.
3.  **Personalized Context**: Context unique to your project and your preferences. This is the most powerful layer, but also the most difficult to create and maintain manually.

The core problem is that **Personalized Context** can go stale quickly. As projects evolve and standards change, developers are forced to constantly and manually update these rules. In addition libraries add features or have new versions and breaking changes, which means you can have drift in your context.

## 2. The Solutions

One solution is to manually curate the context. This is a tedious process and it is easy to miss things.  The other is to use a tool that can automatically update the context.

It's easy to think of these as 2 different options, but in reality you want to automatically update your context AND at times manually curate it.


## 2. The Solution: Automated Context Mining

This is where our partnership with Spec Story comes in. We can transform the developer-AI dialogue from a simple request-response cycle into a rich source of evolving project specifications.

**The Concept**: Your development conversations are a goldmine of preferences. Every time you correct the AI, you are defining a new standard. We can capture this.

### How It Works

1.  **Develop with AI**: A developer uses the AI assistant to generate or refactor code.
2.  **Provide Feedback**: The developer provides corrective feedback in natural language.
3.  **Analyze Dialogue**: Our system, powered by Spec Story's engine, analyzes this conversation to identify explicit and implicit preferences.
4.  **Automate Rule Generation**: The system automatically suggests or applies a new personalized context rule based on the feedback.

This creates a flywheel effect: the more you use the AI, the better it gets at understanding your specific needs, with zero additional manual effort.

## 3. Example: Evolving a FastAPI Endpoint

Let's see how this works with a common tool: FastAPI.

### Initial Request

A developer asks the AI:

> "Create a FastAPI endpoint to add a new user with a name and email."

### V1: AI's First Attempt

The AI generates a functional but generic endpoint.

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class User(BaseModel):
    name: str
    email: str

@app.post("/users/")
async def create_user(user: User):
    # Logic to save the user would go here
    return user
```

### The Conversation (User Feedback)

The code works, but it doesn't match the project's conventions. The developer provides feedback:

> "This is a good start, but for all new resources, I prefer a `201 Created` status code. Also, let's wrap the response in a `{'data': ...}` object for consistency with our other APIs. Finally, please add a server-generated `created_at` timestamp to the user model."

### V2: AI's Refined Code

The AI incorporates the feedback and regenerates the code.

```python
from fastapi import FastAPI, status
from pydantic import BaseModel, Field
from datetime import datetime

app = FastAPI()

class User(BaseModel):
    name: str
    email: str
    created_at: datetime = Field(default_factory=datetime.utcnow)

class UserResponse(BaseModel):
    data: User

@app.post("/users/", status_code=status.HTTP_201_CREATED, response_model=UserResponse)
async def create_user(user: User):
    # Logic to save the user would go here
    return {"data": user}
```

### Automated Rule Generation

Here's the magic. Instead of stopping there, our system analyzes the conversation and proposes a new, durable context rule.

> **New Context Rule Detected:**
>
> **Rule**: FastAPI Creation Standards
>
> -   When creating a new resource via a POST request, the default status code should be `201 Created`.
> -   All API JSON responses should be nested under a top-level `data` key.
> -   When creating new data models, include a non-nullable `created_at` timestamp populated by the server.
>
> **[Apply Rule for Future Generations]**

Now, all future FastAPI endpoints generated by the AI will automatically follow these conventions.

## 4. Conclusion: The Future is Self-Personalizing AI

By mining development conversations, we can eliminate the manual drudgery of context management. This partnership will create an AI assistant that:

-   **Learns and adapts** to your project's unique standards.
-   **Reduces friction** by automating the personalization process.
-   **Keeps context fresh** and relevant as your project evolves.

This is the future of AI-assisted development: a truly collaborative partner that learns from you.
