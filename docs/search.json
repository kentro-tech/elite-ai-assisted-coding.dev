[
  {
    "objectID": "tools-review/cursor.html",
    "href": "tools-review/cursor.html",
    "title": "Cursor Tool Review",
    "section": "",
    "text": "A technical reference for Cursor’s AI-assisted development features"
  },
  {
    "objectID": "tools-review/cursor.html#tab-completion",
    "href": "tools-review/cursor.html#tab-completion",
    "title": "Cursor Tool Review",
    "section": "Tab Completion",
    "text": "Tab Completion\nCursor’s completions use project-wide context rather than just the current file and are very aggressive, which is good in some situations and annoying in others.\n\n\n\n\n\n\nHelpful Use Case\n\n\n\nI was doing an OSS PR to add type hints to a new web development framework called air (very repetitive task). These needed to be matched up to a HTML reference documentation, and agents kept leaving off or added tags. Cursor’s tab comletion let me copy/paste from reference docs then hit tab for it to tab complete and modify to python syntax very quickly. It got the pattern after the first couple and let me get through it all in very little time.\n\n\n\n\n\n\n\n\nUnhelpful Use Case\n\n\n\nI was working on creating examples for a workshop I was teaching on FastHTML Syntax and Project Organization. The tab completion was extremely annoying, because it was project wide it kept trying to autocomplete and change my code to what I did somewhere else. I felt like I was fighting the tab completion constantly and having to keep telling it to go away A LOT because I had a very specific thing in mind I wanted to do."
  },
  {
    "objectID": "tools-review/cursor.html#chatagent-interface-cmdl-cmdi",
    "href": "tools-review/cursor.html#chatagent-interface-cmdl-cmdi",
    "title": "Cursor Tool Review",
    "section": "Chat/Agent Interface (Cmd+L Cmd+I)",
    "text": "Chat/Agent Interface (Cmd+L Cmd+I)\nContext-aware chat that understands project structure. This is pretty helpful with being able to easily reference lots of things with the @ syntax for files. If you have code highlighted when you engage it that will be included in context specifically, and open files will also be in context for you.\n\n\n\n\n\n\nUsage Tip\n\n\n\nI find it really helpful to dump lots of things in a ref folder then @ like everything useful as I go. This can be tutorials I found online, docs, etc. I can @ the URL directly, but the ref folder serves as an aggregator for me that’s a bit easier to keep top of mind and curate as needed than the cursor docs feature IMO.\n\n\nThe Agent gives many options and you get really nice diffs that you can individually review, or accept all, and you can restore back to checkpoints if you accepted changes that you find don’t work well after testing."
  },
  {
    "objectID": "tools-review/cursor.html#inline-editor-cmdk",
    "href": "tools-review/cursor.html#inline-editor-cmdk",
    "title": "Cursor Tool Review",
    "section": "Inline Editor (Cmd+K)",
    "text": "Inline Editor (Cmd+K)\nEdit code in place with AI assistance Cmd+K. This lets you target specific pieces of code to edit. This is extremely helpful for limiting the scope of AI, especially when it’s trying to do too much or you know exactly where the change should happen.\nI often use this to quickly ask it to write a doc string for documentation, or to do things like refactor a hairy logic stuck iside loops or conditionals into functions."
  },
  {
    "objectID": "tools-review/cursor.html#terminal-helped-also-cmdk",
    "href": "tools-review/cursor.html#terminal-helped-also-cmdk",
    "title": "Cursor Tool Review",
    "section": "Terminal helped (also Cmd+K)",
    "text": "Terminal helped (also Cmd+K)\nIn your terminal you can select Cmd+K to have an AI assist that sees that terminals history. This is super helpful for lots of things, like telling you how to run things, git commands you’ve forgotten, telling it to do some curl command you don’t remember all the flags you need, etc.\nThe really nice thing about Cmd+K is it’s very controlled, so it puts the command in your terminal but YOU must run it. This makes it nice because I can ask it to help with even fairly risk things because it won’t be running anything on it’s own."
  },
  {
    "objectID": "tools-review/cursor.html#cursor-rules",
    "href": "tools-review/cursor.html#cursor-rules",
    "title": "Cursor Tool Review",
    "section": "Cursor Rules",
    "text": "Cursor Rules\nCursor Rules are extremely helpful and there’s 4 modes:\n\n\n\nCursor Rules Options\n\n\n\nAlways Apply - Core rules that should never be violated\nApply Manually - Rules you trigger when needed. If you’re really bad at thinking about context, and you’re not going to put a lot of effort in then don’t use this.\nApply Intelligently - This is a great thing to use and provide a good description for the agent to know when to use it.\nApply to Specific Files - File-type or path-specific rules. This can be nice, but you’re liable to set it to a path, restructure something, then forget and this rule will be acidentally deprecated. This is useful in a decently mature code base, or with very general paths like src or docs directory that are not likely to change."
  },
  {
    "objectID": "guides.html",
    "href": "guides.html",
    "title": "Tool Reviews",
    "section": "",
    "text": "Enroll Now on Maven →\n    \n\n\n\n\n\n\n   \n    \n    \n      Order By\n      Default\n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Title\n      \n      \n        Categories\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nOptimize Your Dev Setup For Evals w/ Cursor Rules & MCP\n\n\n\n\n\nJul 15, 2025\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Context Engineering for Coding",
    "section": "",
    "text": "I’ve been deep in the AI coding tools space, testing everything from Cursor to Windsurf to see what actually delivers. Just honest reviews and techniques based on real coding sessions.\n\n\n\n\n\n\nGuides: Universal Techniques and Concepts for using and curating context for AI\nUnbiased Reviews: I pay for these tools and try them myself\nReal Code Examples: Hear exactly what tasks I used them\nPractical Insights: What works, what doesn’t, and when to use each tool\nCondensed Information: I’ve condensed the information to the most useful so you don’t need to spend hours on every tool to know what’s worth your time to try for yourself.\n\n\n\n\n\nI teach a course on Elite AI Assisted Coding with Eleanor Berger. Join us to learn the patterns that 10x your productivity with any AI coding tool.\nThis website had loads of free content I provide. But if you want even more value, more content, that’s even more organized, taught by us live, shows how it works in enterprise settings, and interactive, you can get it here:\n    \n    \n    \n      Enroll Now on Maven →"
  },
  {
    "objectID": "index.html#what-youll-find-here",
    "href": "index.html#what-youll-find-here",
    "title": "Context Engineering for Coding",
    "section": "",
    "text": "Guides: Universal Techniques and Concepts for using and curating context for AI\nUnbiased Reviews: I pay for these tools and try them myself\nReal Code Examples: Hear exactly what tasks I used them\nPractical Insights: What works, what doesn’t, and when to use each tool\nCondensed Information: I’ve condensed the information to the most useful so you don’t need to spend hours on every tool to know what’s worth your time to try for yourself."
  },
  {
    "objectID": "index.html#want-even-more",
    "href": "index.html#want-even-more",
    "title": "Context Engineering for Coding",
    "section": "",
    "text": "I teach a course on Elite AI Assisted Coding with Eleanor Berger. Join us to learn the patterns that 10x your productivity with any AI coding tool.\nThis website had loads of free content I provide. But if you want even more value, more content, that’s even more organized, taught by us live, shows how it works in enterprise settings, and interactive, you can get it here:\n    \n    \n    \n      Enroll Now on Maven →"
  },
  {
    "objectID": "tool-reviews.html",
    "href": "tool-reviews.html",
    "title": "Tool Reviews",
    "section": "",
    "text": "Enroll Now on Maven →\n    \n\n\n\n\n\n\n   \n    \n    \n      Order By\n      Default\n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Title\n      \n      \n        Categories\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\n\nTitle\n\n\n\nCategories\n\n\n\n\n\n\n\n\nJul 24, 2025\n\n\nGemini CLI Tool Review\n\n\nTerminal Agent\n\n\n\n\n\n\nJul 22, 2025\n\n\nCursor Tool Review\n\n\nIDE\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "spec-story-presentation.html",
    "href": "spec-story-presentation.html",
    "title": "Automated Context Personalization with Spec Story",
    "section": "",
    "text": "This presentation outlines a partnership opportunity with Spec Story to solve one of the biggest challenges in AI-assisted development: context personalization. We propose a system to automatically mine developer-AI conversations to create and maintain personalized context, ensuring the AI’s assistance is always aligned with a project’s evolving needs and a developer’s unique tastes."
  },
  {
    "objectID": "spec-story-presentation.html#the-problem-the-manual-context-treadmill",
    "href": "spec-story-presentation.html#the-problem-the-manual-context-treadmill",
    "title": "Automated Context Personalization with Spec Story",
    "section": "1 1. The Problem: The Manual Context Treadmill",
    "text": "1 1. The Problem: The Manual Context Treadmill\nKeeping an AI assistant useful requires feeding it the right context. Why bother?\n\nBetter AI assistance: Context is the foundation of relevant, high-quality AI responses.\nOvercoming Knowledge Cutoffs: Models have outdated information; context provides the latest updates.\nEnforcing Standards: Context helps the AI match your project’s specific tastes, abstractions, and framework usage.\n\nHowever, the current approach to managing this context is manual, brittle, and time-consuming.\n\n1.1 The Three Layers of Context\nWe can think of context in three layers, each requiring progressively more effort to maintain.\n\nGeneral Context: Generic, tool-provided context (e.g., Repomix, GitMCP). It’s a good starting point but lacks specificity.\nCurated Context: Expert-curated context, often from a library author (e.g., llms.txt, official MCP servers). Better, but not tailored to your project.\nPersonalized Context: Context unique to your project and your preferences. This is the most powerful layer, but also the most difficult to create and maintain manually.\n\nThe core problem is that Personalized Context can go stale quickly. As projects evolve and standards change, developers are forced to constantly and manually update these rules. In addition libraries add features or have new versions and breaking changes, which means you can have drift in your context."
  },
  {
    "objectID": "spec-story-presentation.html#the-solutions",
    "href": "spec-story-presentation.html#the-solutions",
    "title": "Automated Context Personalization with Spec Story",
    "section": "2 2. The Solutions",
    "text": "2 2. The Solutions\nOne solution is to manually curate the context. This is a tedious process and it is easy to miss things. The other is to use a tool that can automatically update the context.\nIt’s easy to think of these as 2 different options, but in reality you want to automatically update your context AND at times manually curate it."
  },
  {
    "objectID": "spec-story-presentation.html#the-solution-automated-context-mining",
    "href": "spec-story-presentation.html#the-solution-automated-context-mining",
    "title": "Automated Context Personalization with Spec Story",
    "section": "3 2. The Solution: Automated Context Mining",
    "text": "3 2. The Solution: Automated Context Mining\nThis is where our partnership with Spec Story comes in. We can transform the developer-AI dialogue from a simple request-response cycle into a rich source of evolving project specifications.\nThe Concept: Your development conversations are a goldmine of preferences. Every time you correct the AI, you are defining a new standard. We can capture this.\n\n3.1 How It Works\n\nDevelop with AI: A developer uses the AI assistant to generate or refactor code.\nProvide Feedback: The developer provides corrective feedback in natural language.\nAnalyze Dialogue: Our system, powered by Spec Story’s engine, analyzes this conversation to identify explicit and implicit preferences.\nAutomate Rule Generation: The system automatically suggests or applies a new personalized context rule based on the feedback.\n\nThis creates a flywheel effect: the more you use the AI, the better it gets at understanding your specific needs, with zero additional manual effort."
  },
  {
    "objectID": "spec-story-presentation.html#example-evolving-a-fastapi-endpoint",
    "href": "spec-story-presentation.html#example-evolving-a-fastapi-endpoint",
    "title": "Automated Context Personalization with Spec Story",
    "section": "4 3. Example: Evolving a FastAPI Endpoint",
    "text": "4 3. Example: Evolving a FastAPI Endpoint\nLet’s see how this works with a common tool: FastAPI.\n\n4.1 Initial Request\nA developer asks the AI:\n\n“Create a FastAPI endpoint to add a new user with a name and email.”\n\n\n\n4.2 V1: AI’s First Attempt\nThe AI generates a functional but generic endpoint.\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass User(BaseModel):\n    name: str\n    email: str\n\n@app.post(\"/users/\")\nasync def create_user(user: User):\n    # Logic to save the user would go here\n    return user\n\n\n4.3 The Conversation (User Feedback)\nThe code works, but it doesn’t match the project’s conventions. The developer provides feedback:\n\n“This is a good start, but for all new resources, I prefer a 201 Created status code. Also, let’s wrap the response in a {'data': ...} object for consistency with our other APIs. Finally, please add a server-generated created_at timestamp to the user model.”\n\n\n\n4.4 V2: AI’s Refined Code\nThe AI incorporates the feedback and regenerates the code.\nfrom fastapi import FastAPI, status\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\n\napp = FastAPI()\n\nclass User(BaseModel):\n    name: str\n    email: str\n    created_at: datetime = Field(default_factory=datetime.utcnow)\n\nclass UserResponse(BaseModel):\n    data: User\n\n@app.post(\"/users/\", status_code=status.HTTP_201_CREATED, response_model=UserResponse)\nasync def create_user(user: User):\n    # Logic to save the user would go here\n    return {\"data\": user}\n\n\n4.5 Automated Rule Generation\nHere’s the magic. Instead of stopping there, our system analyzes the conversation and proposes a new, durable context rule.\n\nNew Context Rule Detected:\nRule: FastAPI Creation Standards\n\nWhen creating a new resource via a POST request, the default status code should be 201 Created.\nAll API JSON responses should be nested under a top-level data key.\nWhen creating new data models, include a non-nullable created_at timestamp populated by the server.\n\n[Apply Rule for Future Generations]\n\nNow, all future FastAPI endpoints generated by the AI will automatically follow these conventions."
  },
  {
    "objectID": "spec-story-presentation.html#conclusion-the-future-is-self-personalizing-ai",
    "href": "spec-story-presentation.html#conclusion-the-future-is-self-personalizing-ai",
    "title": "Automated Context Personalization with Spec Story",
    "section": "5 4. Conclusion: The Future is Self-Personalizing AI",
    "text": "5 4. Conclusion: The Future is Self-Personalizing AI\nBy mining development conversations, we can eliminate the manual drudgery of context management. This partnership will create an AI assistant that:\n\nLearns and adapts to your project’s unique standards.\nReduces friction by automating the personalization process.\nKeeps context fresh and relevant as your project evolves.\n\nThis is the future of AI-assisted development: a truly collaborative partner that learns from you."
  },
  {
    "objectID": "guides/context-personalization-101.html",
    "href": "guides/context-personalization-101.html",
    "title": "Optimize Your Dev Setup For Evals w/ Cursor Rules & MCP",
    "section": "",
    "text": "This is a guide to help you optimize your dev setup to get the most out of AI. It’s showed with specific examples for eval frameworks, but the concepts are universally applicable to any tool. It’s a guide to help you understand the different layers of context and how to use them to your advantage for your AI tools.\nThis content was originally created and taught as part of Hamel and Shreya’s AI Evals Course on Maven (30% off with that link!). If you are building AI tools or products, it’s a must-take course. Watch the original video here."
  },
  {
    "objectID": "guides/context-personalization-101.html#why-bother",
    "href": "guides/context-personalization-101.html#why-bother",
    "title": "Optimize Your Dev Setup For Evals w/ Cursor Rules & MCP",
    "section": "1 Why bother?",
    "text": "1 Why bother?\n\nBetter AI assistance\nTraining cutoff may mean outdated info\nSpending time determining what’s important to your project is good - Forces you to understand your tools better\nMake AI better match your taste\nShow how AI integrates with your other tools, abstractions, or framework"
  },
  {
    "objectID": "guides/context-personalization-101.html#the-three-layers",
    "href": "guides/context-personalization-101.html#the-three-layers",
    "title": "Optimize Your Dev Setup For Evals w/ Cursor Rules & MCP",
    "section": "2 The Three Layers",
    "text": "2 The Three Layers\n\nGeneral Context: Generic tool that works on almost anything\n\nRepomix, GitMCP, etc.\n\nCurated Context: Curated by an expert, such as the tool author\n\nLibrary provided MCP, llms.txt, etc.\n\nPersonalized Context: Context that you can create that’s unique to your project\n\nOnly you can make this and it’s uniquely tailored to your taste and needs"
  },
  {
    "objectID": "guides/context-personalization-101.html#general-context",
    "href": "guides/context-personalization-101.html#general-context",
    "title": "Optimize Your Dev Setup For Evals w/ Cursor Rules & MCP",
    "section": "3 General Context",
    "text": "3 General Context\nGeneral context is a good starting point when exploring or unsure about a tool. It’s generic and not optimized for specific needs. It’s fast and easy to set up. It’s useful for quick experimentation and exploration, but it’s not the best for long-term use. Here’s a few examples of general context tools.\n\n\n\n\n\n\nGood For\n\n\n\n\nGood starting point when exploring or unsure about a tool\nGeneric and not optimized for specific needs\nFast and easy to set up\nUseful for quick experimentation and exploration\n\n\n\n\n_BraintrustPhoenixInspect\n\n\n\n\n\nRepoMix is a tool that lets you take a github repo and concatenate all the files based on a pattern into a single file. This is useful for getting lots of context into a single file that you model can easily understand.\n\n3.0.1 Repo Mix\n\n\n\nRepo Mix UI for Braintrust\n\n\n\n\n\n\n3.0.2 Paste Max\nPasteMax is a tool that is a Native App you can install on your machine that lets you concatenate content and files directly in a nice UI. It serves a similar purpose to RepoMix, but it’s a desktop app and has a different UX that many prefer.\n \n\n\n\n\n3.0.3 Git MCP\nGitMCP is a tool that lets you use a github repo as a context source by creating an MCP server to let agents interact with the repo via tools. It’s a different approach to general context, and it’s a good way to be able to let agents interact with the repo via tools. It also has a nice web chat interface that’s great for quick questions to explore the repo.\n\n\n\nGitMCP UI\n\n\n\nRepository chat interface: https://gitmcp.io/UKGovernmentBEIS/inspect_evals/chat\n\n\n\n\nChat interface\n\n\n\n\n\nMCP interface"
  },
  {
    "objectID": "guides/context-personalization-101.html#cursor-rules",
    "href": "guides/context-personalization-101.html#cursor-rules",
    "title": "Optimize Your Dev Setup For Evals w/ Cursor Rules & MCP",
    "section": "4 Cursor Rules",
    "text": "4 Cursor Rules\nCursor rules let you customize how the curso AI assistance will use your rules, this is extremely helpful and should not be overlooked.\n\n4.1 Rule Creation\nYou can create rules in the .cursor/rules directory, but there’s a cursor command that does it for you.\n\n\n\nCursor Rule Creation\n\n\n\n\n4.2 Choosing a Rule Type\nCursor lets you choose a rule type to determine when the models will use the rule context. This is a great way to give a bit more control over model context.\n\n\n\nCursor Rule Types\n\n\n\n\n\n\n\n\nRule Application Strategies\n\n\n\n\nAlways Apply - Core rules that should never be violated\nApply Manually - Rules you trigger when needed. If you’re really bad at thinking about context, and you’re not going to put a lot of effort in then don’t use this.\nApply Intelligently - This is a great thing to use\nApply to Specific Files - File-type or path-specific rules. This can be nice, but you’re liable to set it to a path, restructure something, then forget and this rule will be accidentlaly deprecated."
  },
  {
    "objectID": "guides/context-personalization-101.html#curated-context",
    "href": "guides/context-personalization-101.html#curated-context",
    "title": "Optimize Your Dev Setup For Evals w/ Cursor Rules & MCP",
    "section": "5 Curated Context",
    "text": "5 Curated Context\nCurated context is a good starting point when you want to explore more deeply. It’s provided by the tool author in some format and it’s a good way to get a lot of context into a single file that you model can easily understand. This will usually be better than general context, but still not a very tiny investment to set up. However, not every tool or library provides curated context.\n\n\n\n\n\n\nGood For\n\n\n\n\nYou want to explore more deeply\nIt’s provided by the tool author in some format\n\n\n\n\n_BraintrustPhoenixInspectManual Approaches\n\n\n\n\n\n\n5.0.0.1 MCP (Model Context Protocol)\nBraintrust provides a MCP server that your AI agents can use. This is a lot like GitMCP we saw above, but created by the Braintrust team specifically for Braintrust so it’s much better.\n\nOfficial MCP server: https://www.braintrust.dev/docs/reference/mcp\nProvides structured access to Braintrust functionality\n\nTo set up the MCP server with Cursor, you can use the following settings.\n\n\n\nCursor MCP Settings\n\n\n\n\n\nCursor MCP Json\n\n\n\n\n\n\n5.0.0.2 LLMs.txt\nPhoenix provides an file based in the llms.txt spec format. This is a format that allows for use as static context in a flat file, or as a tool that an MCP server can use to crawl it agentally.\n\nStandard Format for Pheonix: https://arize.com/docs/phoenix/llms.txt\nLangchain MCP documentation tool: https://github.com/langchain-ai/mcpdoc\n\n\n\n\n\n5.0.0.3 llms.txt\nFor Pheonix, I provided a link to lanchain’s MCP server that lets you use the llms.txt file as a tool. For Inspect, let’s use the llms.txt spec to use the flat files as context to see the difference.\n\nStandard format: https://inspect.aisi.org.uk/llms.txt\nFull version: https://inspect.aisi.org.uk/llms-full.txt\nIndividual Pages as Context: https://inspect.aisi.org.uk/index.html.md\n\n\n\n\nManual curation of context is also a great way to have the most control. There is typically a tradeoff between the amount of time you spend curating the context and the quality of the context. You will get better results if you spend more time carefully curating the context, and whether that payoff is worth the time is dependent on a few things:\n\nHow long will you be using this tool and how much? If you use it daily and will for years, it’s worth the time to curate the context.\nHow good is the library provided context? If they have carefully curated the context for llms specifically and the tool authors use it themselves, the often it works pretty great out of the box. Sadly, most tools don’t do this (yet).\n\n\n5.0.0.4 Jina AI\nJina AI is an easy way to turn any html page into a markdown file. Markdown is much better context for HTML, because there’s loads of unneccesary noise in the HTML that doesn’t add value (styling classes, js interactivity, server calls, social media icons, etc.)\n\n\n\n5.0.0.5 Copy Outer HTML\nBy going more manual you can remove the noise and get a more focused context. This is a great way to get a more focused context, but it’s a more work. The main benefits here over Jina AI is you often can remove lots of unneeded sections like footers, table of contents, sidebars, navigation, etc.\nCopying the outer HTML and feeding that into Web2Md is the best workflow I’ve found for this.\n\n\n\n5.0.0.6 Web 2 MD"
  },
  {
    "objectID": "guides/context-personalization-101.html#personalized-context",
    "href": "guides/context-personalization-101.html#personalized-context",
    "title": "Optimize Your Dev Setup For Evals w/ Cursor Rules & MCP",
    "section": "6 Personalized Context",
    "text": "6 Personalized Context\nPersonalized context is the most time consuming and the most effective. It’s not something anyone can create for you because it matches your taste and decisions made for you specific project.\n\n\n\n\n\n\nGood For\n\n\n\n\nYou know you’re going to be using this thing for months\nIt’s worthwhile to invest a bit of time for better AI assistance\n\n\n\nLet’s look at some examples of diffs that you may want to do to your context for more personalized context.\n\n_BraintrustPhoenixInspect\n\n\n\n\n\n\n6.0.0.1 Use Case Specific Context\n\n\n\nUse case specific examples\n\n\n\n\n6.0.0.2 Reducing Context Size\n\n\n\nReducing context for efficiency\n\n\n\n\n6.0.0.3 Opinionated Best Practices\n\n\n\nDefining coding standards\n\n\n\n\n6.0.0.4 Multi-Language Support\n\n\n\nSupporting multiple languages\n\n\n\n\n6.0.0.5 Code Style Preferences\n\n\n\nInsert your coding style\n\n\n\n\n6.0.0.6 Performance Considerations\n\n\n\nRemoving timing-specific code\n\n\n\n\n\n\n6.0.0.7 Fix Formatting\n\n\n\nFix Formatting\n\n\n\n\n6.0.0.8 Rm hosted options you’re not using\n\n\n\nRemove Cloud Hosting\n\n\n\n\n6.0.0.9 Put in project specific info\n\n\n\nPut in Real Endpoints\n\n\n\n\n6.0.0.10 Remove Unused Languages\n\n\n\nRemove Typescript\n\n\n\n\n\n\n6.0.0.11 Human prose -&gt; AI Instruction\n\n\n\nChange tip to instruction for env var clarity\n\n\n\n\n6.0.0.12 Remove examples not relevant to you\n\n\n\nRemove non-relevant examples"
  },
  {
    "objectID": "tools-review/gemini-cli.html",
    "href": "tools-review/gemini-cli.html",
    "title": "Gemini CLI Tool Review",
    "section": "",
    "text": "For the next tool review in my series, I decided to use the Gemini CLI."
  },
  {
    "objectID": "tools-review/gemini-cli.html#the-task",
    "href": "tools-review/gemini-cli.html#the-task",
    "title": "Gemini CLI Tool Review",
    "section": "The Task",
    "text": "The Task\nMy desktop is cluttered with ~ a billion unnamed screenshots and screen recordings. I’ve wanted to clean them for a while, but renaming them is a huge pain.\nBecause the Gemini models are to be the best at multimodal tasks like image and video, Gemini CLI felt like it should be a good choice. I decided to tackle this in 2 phases:\n\nTry using the Gemini CLI out of the box to rename this files with 0 effort by looking at image and video content.\nCreate a desktop app that has file navigations and single vs bulk file renaming to make a genral solution.\n\nThat way I should get a good feel for the tool’s capabilities and learn a bit about building a desktop app. This review is part of my research for my “AI Assisted Coding” course, where I teach how to get the most out of AI tools.\n    \n    \n    \n      Enroll Now on Maven →"
  },
  {
    "objectID": "tools-review/gemini-cli.html#the-messy-desktop",
    "href": "tools-review/gemini-cli.html#the-messy-desktop",
    "title": "Gemini CLI Tool Review",
    "section": "The Messy Desktop",
    "text": "The Messy Desktop\nAs you can see, I have a lot of unnamed screenshots and I have no idea what they are. I’ve tried to rewrite them but it’s a pain so I didn’t get far [00:01:09]\n\n\n\nA list of files with generic names like “Screenshot 2025-07-23…”"
  },
  {
    "objectID": "tools-review/gemini-cli.html#using-the-gemini-cli-for-renaming",
    "href": "tools-review/gemini-cli.html#using-the-gemini-cli-for-renaming",
    "title": "Gemini CLI Tool Review",
    "section": "Using the Gemini CLI for Renaming",
    "text": "Using the Gemini CLI for Renaming\nI fired up the Gemini CLI and gave it the task of renaming the files without any code. [00:01:24] I was pleased to see that it did a great job of analyzing the content of the images and videos and suggesting meaningful names.\n\n\n\nGemini CLI terminal showing the model analyzing screenshots\n\n\nThe CLI renamed a batch of files, and the new names were descriptive and accurate. [00:01:42]\n\n\n\nFive screenshots renamed with descriptive names\n\n\nHere’s another example of the CLI renaming a screenshot with a descriptive name. [00:01:39]\n\n\n\nA screenshot being renamed by the Gemini CLI\n\n\nThe tool also handled video files (.mov) just as effectively as images. [00:02:00]\n\n\n\nThe Gemini CLI analyzing and renaming screen recordings\n\n\nIt didn’t keep track of the work progress well however. I found that the CLI would sometimes stop a lot before completing the entire task, and I had to remind it to do a ls | grep Screenshot of the directory to see if there’s more to do to get it to continue. [00:02:15]\n\n\n\nA terminal screenshot showing a list of remaining files to be renamed"
  },
  {
    "objectID": "tools-review/gemini-cli.html#building-a-desktop-app-with-the-gemini-cli",
    "href": "tools-review/gemini-cli.html#building-a-desktop-app-with-the-gemini-cli",
    "title": "Gemini CLI Tool Review",
    "section": "Building a Desktop App with the Gemini CLI",
    "text": "Building a Desktop App with the Gemini CLI\nOnce I confirmed that the core functionality was possible, I moved on to building a desktop application to make this renaming process easier in the future. I hadn’t built a desktop app before, so this was fun.\nA feature I particularly liked was the ability to modify the proposed changes in an external editor before applying them. [00:03:09] This gave me more a bit more control.\n\n\n\nThe Gemini CLI prompt to modify a diff in an external editor\n\n\nI chose to open in cursor, and it gave me an editable diff view I could modify before the changes are applied.\n\n\n\nA Python code snippet for folder selection\n\n\nThe Gemini CLI also generated a plan for the application before it started coding, which is nice. Claude Code and many other tools do this too. But it’s still nice. [00:03:33]\n\n\n\nThe AI’s plan for the file renamer application\n\n\nThe end result was a functional-ish, but very buggy, desktop application. I was able to select a directory, have the AI suggest new names for the files, and then apply those names. [00:03:54]\n\n\n\nThe AI-generated file renamer application\n\n\nThe application included logging, which was helpful. [00:04:42]\n\n\n\nThe log file for the AI file renamer application"
  },
  {
    "objectID": "tools-review/gemini-cli.html#code-quality-and-bugs",
    "href": "tools-review/gemini-cli.html#code-quality-and-bugs",
    "title": "Gemini CLI Tool Review",
    "section": "Code Quality and Bugs",
    "text": "Code Quality and Bugs\nWhile the app “worked,” it had several major bugs.\n\nI couldn’t select individual files, and the app would often hang after processing one directory. [00:04:06]\nAfter doing it’s first bulk rename operation it would somehow get into a state where no additional renamings would work so the whole app would need to be restarted. There were no errors logged.\n\nWhen I dove into the code more carefully, I found the common AI code culprits such as overuse of generic try...except blocks that would catch exceptions and simply print them to the console. [00:04:57] This hides bugs and make the application less robust and harder to fix but appear to work at a glance.\n\n\n\nA code snippet showing generic exception handlers"
  }
]